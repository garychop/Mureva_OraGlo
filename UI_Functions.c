//	Filename:  UI_Functions.h
//	Author:  Paul Wittibschlager
//	Date Created:  08/27/2018
//	Company:  Valtronic, USA
//	Project:   Lumitex OraGlo Control Board
//	Project number:  DD400004
//	Description:  This file contains functions to support the user interface.

#include <stdbool.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <float.h>

// Debugging macros, ensure they are NOT defined for production builds
//#define TESTING_MOUTHPIECE_EXPIRED 1
//#define USE_SHORT_THERAPY_TIME 1

#define    FCY    16000000UL  // required by libpic30.h    
#include <libpic30.h>

#include "mcc_generated_files/mcc.h"
#include "Support_Functions.h"
#include "Test_Functions.h"
#include "flashmem.h"
#include "pushbuttons.h"
#include "UI_Functions.h"
#include "lcd.h"
#include "rtc.h"
#include "rtcc.h"
#include "hw_watchdog.h"
#include "timers.h"
#include "ledboard.h"
#include "screensaver.h"
#include "rgbled.h"
#include "mca.h"

#define MAX_NUM_MINUTES  9

#define SETTINGS_PER_UI_STATE  20

// Maximum length of setting name as displayed via UART interface
#define MAXLEN_SETTING_NAME  12

// Starting Address in FLASH where defaults are stored = 513*64, we need 5 pages (13 states * 20 settings * 4 Bytes = 1040 Bytes --> Each page 256 Bytes)
const uint32_t FLASH_ADDR_OF_SETTINGS = 32832;
static const uint32_t USER_INTERFACE_SETTINGS_START_PAGE = 513;
static const uint32_t USER_INTERFACE_SETTINGS_END_PAGE = 517; // +5 Pages

// No need to monitor START_WDOG
static const uint16_t STARTUP_ERROR = (BASIC_DEVICE_READY_ERROR | THERAPY_ON);

// Used in generating the ID numbers of the countdown tick mark images
static const uint16_t CNTDWN_DISPLAY_BASE = 4000; 
 
// Used in generating the numeral indicating the number of minutes left
static const uint16_t MINUTE_INDICATOR_BASE = 4100; 

/* These indices are used to identify the proper overlay image
   for a particular error message.  The identifier for this image overlay
 * is generated by adding Read_UI_Setting(ERROR_STATE, IMAGE_2) to
 * the corresponding enum.
 */
typedef enum {
    ERROR_UNKNOWN = 0,
    ERROR_MOUTHPIECE_DETACHED,
    ERROR_TEMP_TOO_HIGH,
    ERROR_CURRENT_TOO_HIGH,
    ERROR_CURRENT_TOO_LOW,
    ERROR_CURRENT_SOURCE_FAULT,
    ERROR_SOFTWARE_WATCHDOG_TIMEOUT,
    ERROR_HARDWARE_WATCHDOG_TIMEOUT,
    ERROR_HW_WDOG_ENABLE,
    ERROR_THERAPY_ON,
    ERROR_START_WDOG,
    ERROR_24VDC,
    ERROR_5VDC,
    ERROR_33VDC,
    ERROR_ALARM,
    ERROR_RGB_LED,
    ERROR_LCD,
    ERROR_FAN,
    ERROR_FLASH_MEM,
    ERROR_LED_BOARD_EEPROM,
    ERROR_PUSHBUTTON,
    ERROR_LED_CURRENT_INACCURATE,
    ERROR_I2C,
    ERROR_BATTERY,
    ERROR_MCA_READING,
    ERROR_MCA_EXPIRED,
    ERROR_MCA_PERIOD
} error_index_t;

typedef enum {
    ERROR_IMG_NULL = 0,
    ERROR_IMG_ALARM,
    ERROR_IMG_LED_CURRENT_INACCURATE,
    ERROR_IMG_CURRENT_SOURCE_FAULT,
    ERROR_IMG_CURRENT_TOO_HIGH,
    ERROR_IMG_CURRENT_TOO_LOW,
    ERROR_IMG_5VDC,
    ERROR_IMG_33VDC,
    ERROR_IMG_24VDC,
    ERROR_IMG_START_WDOG,
    ERROR_IMG_THERAPY_ON,
    ERROR_IMG_HW_WDOG_ENABLE,
    ERROR_IMG_FAN,
    ERROR_IMG_FLASH_MEM,
    ERROR_IMG_HARDWARE_WATCHDOG_TIMEOUT,
    ERROR_IMG_I2C,
    ERROR_IMG_LCD,
    ERROR_IMG_LED_BOARD_EEPROM,
    ERROR_IMG_PUSHBUTTON,
    ERROR_IMG_RGB_LED,
    ERROR_IMG_SOFTWARE_WATCHDOG_TIMEOUT,
    ERROR_IMG_TEMP_TOO_HIGH,
    ERROR_IMG_UNKNOWN
} error_image_index_t;

//Serial number of MCA  (+7 ensures that there is sufficient room for S/N + CRC)
static uint8_t g_MCA_SN[MCA_SERIAL_NUM_LEN + 7]     =   "---------";
static uint8_t g_MCA_SN_old[MCA_SERIAL_NUM_LEN + 7] =   "xxxxxxxxx";

// Most recent timer value for which the countdown display was updated
static uint16_t g_most_recent_update_time;

// LED current to be used in milliamps.  Retrieved from LED EEPROM and multiplied by cal factor from MCA EEPROM
static uint16_t g_specified_LED_current = 0; 

static bool g_mouthpiece_removed_during_operation = false;
static bool g_MCA_error = false;
static uint8_t g_MCA_SwitchDebounceCounter; 

const static uint8_t g_display_xpos = 75;
//static uint8_t g_display_ypos_1_4 = 90;
const static uint8_t g_display_ypos_2_4 = 123;
//static uint8_t g_display_ypos_3_4 = 156;
//static uint8_t g_display_ypos_4_4 = 190;

const static uint8_t g_display_ypos_1_3 = 100;
const static uint8_t g_display_ypos_2_3 = 140;
const static uint8_t g_display_ypos_3_3 = 180;

const static uint8_t g_display_ypos_1_2 = 115;
const static uint8_t g_display_ypos_2_2 = 165;

static bool g_ResumeFromPause = false;

static void ExecutePowerUpStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *p_current_phase);
static void ExecuteStandbyStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *current_phase);
static void ExecuteInsertMCAStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *current_phase);
static void ExecuteReadingErrorMCAStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *current_phase);
static void ExecuteExpiredMCAStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *current_phase);
static void ExecuteMCAPeriodStateEvents(uint16_t hw_wdog_status, 
                                      ui_state_t *current_phase);
static void ExecuteDetachedMCAStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *current_phase);
static void ExecuteReadingMCAStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *current_phase);
static void ExecuteVerifySNStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *current_phase);
static void ExecuteReadyStateEvents(uint16_t hw_wdog_status,
                                    ui_state_t *current_phase);
static void ExecuteResumeMCAStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *current_phase);
static void ExecuteOperationStateEvents(uint16_t hw_wdog_status,
                                        ui_state_t *current_phase);
static void ExecuteTherapyCompleteStateEvents(uint16_t hw_wdog_status,
                                              ui_state_t *current_phase);
static void ExecutePausedStateEvents(uint16_t hw_wdog_status,
                                     ui_state_t *current_phase);
static void ExecuteErrorStateEvents(uint16_t hw_wdog_status,
                                    ui_state_t *current_phase);
static void EnterUIState(ui_state_t *p_current_phase, ui_state_t next_phase,
                         ui_setting_t img_setting, uint64_t aux_info);
static void EnterErrorStateFromBIST(ui_state_t *p_current_phase, uint16_t bist_results);
static bool EnterErrorStateIfBistFails(ui_state_t *p_current_phase,
                                       bool replace_power_up_screen);
static bool PerformPowerUpSequence(uint16_t *post_results);
static void UpdateTimerDisplay(uint16_t timer, bool first_minute);
static error_index_t DisplayTestResultsByPriority(uint16_t selftest_status, uint16_t watchdog_status, uint16_t system_status);
static void UpdateTimerDial(uint16_t timer);
static void DisplayUISettings(void);
static void DisplayUISettingsLegend(void);
static void InitializeUISettings(void);
static void SetUISetting(void);
static void EnterSettingIntoFlash(uint32_t phase, uint32_t setting,
                                  uint32_t value);
//static void GetSystemStatus(uint16_t *system_status);

void InitializeUserInterface(void)
{
    ScreenSaverInit(ReadUISetting(STANDBY_STATE, IMAGE_2),
                    ReadUISetting(STANDBY_STATE, SPARE0),
                    ReadUISetting(STANDBY_STATE, SPARE1),
                    ReadUISetting(STANDBY_STATE, SPARE2));
}


/* Description:  This function implements a submenu of selections to program
 *               the flash memory with settings that control the user interface,
 *               such as images to display, colors for the RGB LED, and LED
 *               blink times
 * Preconditions:  SPI for the flash interface and UART module will need
 *                 to be initialized for comumication
 * Arguments:  void
 * Returns:  void
 */
void UserInterfaceSubmenu(void)
{
	bool done = false;

	// Disable watchdog timer
	_SWDTEN = 0;
    while(!done)
    {
        printf("\n\r");
        printf("\n\r");
        printf("\n\r    User Interface Sub-Menu");
        printf("\n\r--------------------------------------------------------------------------------------------------");
        printf("\n\r  0 = Read user interface settings from FLASH                                                   ");
        printf("\n\r  1 = Initialize all user interface settings (these are default settings)                       ");
        printf("\n\r  2 = Write user interface settings into FLASH, one at a time                                   ");
        printf("\n\r  3 = Display legend for user interface settings                                                ");
        printf("\n\r  4 = Notes on User Interface");
        printf("\n\r  5 = Exit");
        printf("\n\r");

        switch (GetCharWithinLimits('0', '5'))
        {
            case '0':
                DisplayUISettings();
                break;
            case '1':
                InitializeUISettings();
                break;
            case '2':
                SetUISetting();
                break;
            case '3':
                DisplayUISettingsLegend();
                break;
            case '4':
                UserInterfacePrintNotes();
                break;
            case '5':
                done = true;
                break;
            default:   // default included to satisfy static code analyzers
                break;
        }

        printf("\n\r\n\r");
    }
}

void UserInterfacePrintNotes()
{
    printf("\n\r--------------------------------------------------------------------------------------------------");
    printf("\n\r The MuReva User Interface has the following \"phases\"   ");
    printf("\n\r 1.  Powering Up   ");
    printf("\n\r 2.  Stand-By ");
    printf("\n\r 3.  Ready ");
    printf("\n\r 4.  Operation ");
    printf("\n\r 5.  Therapy Complete ");
    printf("\n\r 6.  Paused ");
    printf("\n\r 7.  Error Condition ");
    printf("\n\r 8.  Insert MCA ");
    printf("\n\r 9.  Reading MCA ");
    printf("\n\r 10. Verify SN ");
    printf("\n\r 11. MCA Detached ");
    printf("\n\r 12. MCA Reading Error ");
    printf("\n\r 13. MCA Expired ");

    printf("\n\r    ");
    printf("\n\r Notes on the MuReva User Interface:   ");
    printf("\n\r    All phases have the following user settings stored in FLASH:");
    printf("\n\r    1.  Images (1 through 4) that are displayed in succession.  The image file must be stored in the FLASH. ");
    printf("\n\r        If the image ID# is not found in the FLASH's Image Table, then the image is not displayed.");
    printf("\n\r        The images are overlayed:  4 on top of 3 on top of 2 on top of 1.");
    printf("\n\r        In some cases, images from the next phase are overlayed upon the image from the previous phase.");
    printf("\n\r    2.  Time for each image to be displayed (1 through 4).  This is the time in milliSeconds that each image");
    printf("\n\r        will be displayed on the screen.  The images are overlayed, starting with image 1.");
    printf("\n\r        After the time expires, the next image in succession is displayed.  If no other images are found");
    printf("\n\r        or the last image was displayed, then the final image on the LCD is unchanged.");
    printf("\n\r    3.  Colors (1 and 2) for the RGB LED indicator.  Each color is defined by the amount of Red, Green, and Blue ");
    printf("\n\r        to be included.  Amounts are in the range of 0 to 255.  Two colors are defined so that the RGB LED");
    printf("\n\r        can blink between the two colors.  If only one color is desired then just program both colors to be");
    printf("\n\r        the same.");
    printf("\n\r    4.  Time for each color to be displayed (5 and 6).  This is the time in milliSeconds that each color will");
    printf("\n\r        be displayed.  The LED will oscillate between the two colors indefinitely.  If only one color is desired");
    printf("\n\r        then just program both colors to be the same and use the default times of 1000 milliSeconds. ");
    printf("\n\r     ");
    printf("\n\r    There are additional settings such as therapy time, LCD screensaver, etc.  During the Operation phase,");
    printf("\n\r    the clock image is overlayed after images 1 through 4 have been displayed.  The clock image is not programmable");
    printf("\n\r    and happens automatically.");
    printf("\n\r     ");
 
}



/*  This differs fromReadLEDBoardSpecifiedCurrent() in that one could
 *  use the menu system to change whatever value is stored within EEPROM.
 *  In contrast, this variable is only set when entering the operation
 *  state, so it constitutes the value actually being used.
 */
uint16_t GetCurrentlyUsedLEDCurrent(void)
{
    return g_specified_LED_current;
}


/*
 *  Description:  Displays the full clock image and then erases the clock
 *               ticks, one by one, as though counting down.  Accessible
 *               from the test interface and used for testing and debugging
 */
void GenerateCountdownDisplay(void)
{
    int i;

    WriteImageToLCD(ReadUISetting(OPERATION_STATE, IMAGE_1), false, false); 
    for (i = 60; i > 0; i--)
    {
        StartGenericCountdownTimer(1);
        WriteImageToLCD(CNTDWN_DISPLAY_BASE + i, false, false);
        WaitForGenericCountdownTimer(1);
    }

    StartGenericCountdownTimer(1);
    WriteImageToLCD(CNTDWN_DISPLAY_BASE + 61, false, false);
    WaitForGenericCountdownTimer(0);
    WriteImageToLCD(ReadUISetting(OPERATION_STATE, IMAGE_1), false, false); 
}


/* Description:  This function reads the User Interface settings from the FLASH.
 *               Settings such as the images to display, colors for the RGB LED,
 *               and times
 * Preconditions:  SPI for the FLASH interface. UART module will need
 *                 initialized for com.
 * Arguments:  'Phase' is the phase of the User Interface as defined in the
 *             Engineering Usability File Setting as defined in the
 *             User_Interface_Submenu()
 * Returns:  The desired setting.  There is one caveat though; if one of the
 *           color settings is selected, the unsigned 32-bit return value will
 *           always have all three colors (RGB) for that particular
 *           color setting.  For example, if Setting = 9 indicating Color1R,
 *           the returned value will be all 3 colors:  0x00BBGGRR as defined
 *           by the three settings:  Color1R, Color1G, Color1B.  You will get
 *           the same return value for Setting = 9, 10, or 11.  Similar for
 *           Color2.  This was done so that the return value can be immediately
 *           input the Write_RGB_LED() function
 */
uint32_t ReadUISetting(ui_state_t phase, ui_setting_t setting)
{
    uint32_t setting_value = 0; // The user interface setting read from flash
    uint32_t red = 0; // Red, green, and blue intensity settings from flash
    uint32_t green = 0; 
    uint32_t blue = 0;
    
    ReadFlash(FLASH_ADDR_OF_SETTINGS + NUM_UI_STATES*setting + phase, &setting_value, 1, 0);  //read one 32-bit value

    switch (setting)
    {
        case COLOR_1_R:
        case COLOR_1_G:
        case COLOR_1_B:
            ReadFlash(FLASH_ADDR_OF_SETTINGS + NUM_UI_STATES*COLOR_1_R + phase, &setting_value, 1, 0);
            red = setting_value;
            ReadFlash(FLASH_ADDR_OF_SETTINGS + NUM_UI_STATES*COLOR_1_G + phase, &setting_value, 1, 0);
            green = setting_value;
            ReadFlash(FLASH_ADDR_OF_SETTINGS + NUM_UI_STATES*COLOR_1_B + phase, &setting_value, 1, 0);
            blue = setting_value;
            setting_value = ((red & 0x000000FF) << 0) | ((green & 0x000000FF) << 8) | ((blue & 0x000000FF) << 16);
            break;
        case COLOR_2_R:
        case COLOR_2_G:
        case COLOR_2_B:
            ReadFlash(FLASH_ADDR_OF_SETTINGS + NUM_UI_STATES*COLOR_2_R + phase, &setting_value, 1, 0);
            red = setting_value;
            ReadFlash(FLASH_ADDR_OF_SETTINGS + NUM_UI_STATES*COLOR_2_G + phase, &setting_value, 1, 0);
            green = setting_value;
            ReadFlash(FLASH_ADDR_OF_SETTINGS + NUM_UI_STATES*COLOR_2_B+ phase, &setting_value, 1, 0);
            blue = setting_value;
            setting_value = ((red & 0x000000FF) << 0) | ((green & 0x000000FF) << 8) | ((blue & 0x000000FF) << 16);
            break;
        default:
            break;
    }
    return setting_value;
}


/* Description:  This function implements the User Interface state machine by 
 *               looking at all inputs that can change phase and updating the 
 *               'Phase' argument with the new phase.
 *               This is regularly called by the main() function
 * 
 *               The phase of the user interface as defined below and in
 *               MuReva's Usability File
 *               1.Power Up     2.Stand-By     3.Ready      4.Operate      5.Complete  
 *               6.Paused       7.Error        8.Insert MCA 9.Reading MCA  10.Verify SN
 */
void UpdateUIStateMachine(void)
{
    // This is the state (or "phase", to use MuReva's terminology)
    // within the UI state machine)
    // Declared static so that it is initialized only once but does retain its value, whatever it
    // happens to be over the lifetime of the program
    static ui_state_t current_phase = POWER_UP_STATE; 
    
    // I changed the variable name to "local_" to reduce confusion of local variable
    // versus passed parameter.
    uint16_t local_hw_wdog_status;   //This holds the status bits from the hardware watchdog function   
    TestHWWdog(&local_hw_wdog_status, NULL, false);  //Get the current status from the hardware watchdog 
    
    switch (current_phase)
    {   
        case POWER_UP_STATE:
            ExecutePowerUpStateEvents(local_hw_wdog_status, &current_phase);
            g_ResumeFromPause = false;
            break;  
            
        case STANDBY_STATE:
            ExecuteStandbyStateEvents(local_hw_wdog_status, &current_phase);
            break;  
            
        case INSERT_MCA_STATE:
            ExecuteInsertMCAStateEvents(local_hw_wdog_status, &current_phase);
            break;  
            
        case READING_MCA_STATE:
            ExecuteReadingMCAStateEvents(local_hw_wdog_status, &current_phase);
            break;  
            
        case VERIFY_SN_STATE:
            ExecuteVerifySNStateEvents(local_hw_wdog_status, &current_phase);
            break;  
            
        case READY_STATE:
            ExecuteReadyStateEvents(local_hw_wdog_status, &current_phase);
            break;  

        case MCA_RESUME_CONFIRM_STATE:
            ExecuteResumeMCAStateEvents(local_hw_wdog_status, &current_phase);
            break;
            
        case OPERATION_STATE: 
            ExecuteOperationStateEvents(local_hw_wdog_status, &current_phase);
            break;  
            
        case THERAPY_COMPLETE_STATE:
            ExecuteTherapyCompleteStateEvents(local_hw_wdog_status, &current_phase);
            g_ResumeFromPause = false;
            break;  
            
        case PAUSED_STATE: 
            ExecutePausedStateEvents(local_hw_wdog_status, &current_phase);
            g_ResumeFromPause = true;
            break;  
            
        case ERROR_STATE:  
            ExecuteErrorStateEvents(local_hw_wdog_status, &current_phase);
            break;  
            
        case MCA_DETACHED_STATE:  
            ExecuteDetachedMCAStateEvents(local_hw_wdog_status, &current_phase);
            break;
        
        case MCA_READING_ERROR_STATE:
            ExecuteReadingErrorMCAStateEvents(local_hw_wdog_status, &current_phase);
            break;
         
        case MCA_EXPIRED_STATE:
            ExecuteExpiredMCAStateEvents(local_hw_wdog_status, &current_phase);
            break;
            
        case MCA_PERIOD_ERROR_STATE:
            ExecuteMCAPeriodStateEvents(local_hw_wdog_status, &current_phase);
            break;
            
        default:
            // Generate "unknown error" message
            EnterUIState(&current_phase, ERROR_STATE, IMAGE_1, 0);
            break;
    }
}

/*  The application iterates through this function while in the 
 *  power-up state.
 * 
 *  Parameters:
 *    hw_wdog_status:   Bitflags for hardware watchdog results
 *    p_current_phase:  Pointer used for updating the current state
 *                       as needed
 */
static void ExecutePowerUpStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *p_current_phase)
{
    static bool startup = true;
    
    if (startup)
    {
        startup = false; // Ensures that we only execute this block once
        InitializeLCD();  //programs registers in LCD needed to display images
        // We are already in the power up state, but this function 
        // call initializes the LEDs and the image displayed on the LCD 
        EnterUIState(p_current_phase, POWER_UP_STATE, IMAGE_1, 0);
        
        StartGenericCountdownTimer(8);    // [SDS#7.4.1] Boot time less than 10 seconds
        uint16_t post_results;
        if (!PerformPowerUpSequence(&post_results)) // Run POST, determine if there was an error
        {
            ClearGenericCountdownTimer(); // Stop the startup timer
            // Do not show image, the error state will take care of that
            // WriteImageToLCD(ReadUISetting(POWER_UP_STATE, IMAGE_2), true, false);
            
            /*  The 'aux_info' parameter in EnterUIState() should
             *  have a '1' bit for each of the self-test (POST or BIST)
             *  results that fails.  In contrast, 'post_results'
             *  has a '1' for each test that passed.
             *     To prevent false errors, we first assign a '1' 
             *  result to each of the tests that are not part of
             *  the POST requirements.  Then we toggle each bit to
             *  comply with the protocol required in the 'aux_info'
             *  parameter.  */
            uint16_t test_results = (post_results & POST_REQUIREMENTS) |
                ~POST_REQUIREMENTS;
            test_results ^= 0xFFFF;
            EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1,
                ((uint64_t) test_results) << 16);
        }
    }
    else if (GenericCountdownTimerElapsed())
    {   
        //Paint the background black in preparation for the next image
        //This keeps the MuReva logo on there the maximum amount of time
        //Until we are ready to go to one of these first two phases
        BlankOutDisplay(false);   //paint background color over entire display
        if (hw_wdog_status & MOUTHPIECE_ATTACHED)
        {
            EnterUIState(p_current_phase, READING_MCA_STATE, IMAGE_1, 0);
        }
        else
        {
#ifdef TESTING_MOUTHPIECE_EXPIRED            
            EnterUIState(p_current_phase, MCA_EXPIRED_STATE, IMAGE_1, 0);
#else
            EnterUIState(p_current_phase, INSERT_MCA_STATE, IMAGE_1, 0);
#endif
        }
    }
    else 
    {
        EnterErrorStateIfBistFails(p_current_phase, true);
    }
}

/*  The application iterates through this function while in the 
 *  stand-by state.
 * 
 *  Parameters:
 *    hw_wdog_status:   Bitflags for hardware watchdog results
 *    p_current_phase:  Pointer used for updating the current state
 *                       as needed
 */
static void ExecuteStandbyStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *p_current_phase)
{
    // The StandBy is the START CASE after 1h inactivity
    
    if (hw_wdog_status & STARTUP_ERROR)
    {
        EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1,
                        hw_wdog_status & STARTUP_ERROR);
    }
    else if (!EnterErrorStateIfBistFails(p_current_phase, false))
    {
        /* No error was detected, wait in loop until power off */

        // Return to same state
        EnterUIState(p_current_phase, *p_current_phase, IMAGE_1, 0);
    }
}


/*  The application iterates through this function while in the 
 *  Insert MCA state.
 * 
 *  Parameters:
 *    hw_wdog_status:   Bitflags for hardware watchdog results
 *    p_current_phase:  Pointer used for updating the current state
 *                       as needed
 */
static void ExecuteInsertMCAStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *p_current_phase)
{
//    if (!ScreenSaverIsActive())
//    {
//        //Display message on LCD                
//        DisplayText("   INSERT", g_display_xpos, g_display_ypos_1_3);
//        DisplayText("   MOUTH", g_display_xpos, g_display_ypos_2_3);
//        DisplayText("    PIECE", g_display_xpos, g_display_ypos_3_3);
//    }
    
    if(ScreenShouldBeBlank())
    {
        EnterUIState(p_current_phase, STANDBY_STATE, IMAGE_1, 0);
    }
    else if (hw_wdog_status & STARTUP_ERROR)
    {
        EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1,
                        hw_wdog_status & STARTUP_ERROR);
    }
    else if (hw_wdog_status & MOUTHPIECE_ATTACHED)
    {
        g_MCA_error = false;  //clear any previous MCA error now that we are inserting a new one
        EnterUIState(p_current_phase, READING_MCA_STATE, IMAGE_1, 0);
    }
    else if (!EnterErrorStateIfBistFails(p_current_phase, false))
    {
        /* No error was detected, so we proceed normally, i.e. wait for
         * the button to be pressed and execute screensaver ops as needed */
        if (PushbuttonPressed(PUSHBUTTON_1))
        {
            // Return to same state, resetting the display and screensaver timer
            EnterUIState(p_current_phase, *p_current_phase, IMAGE_1, 0);
        }
        if (ScreenSaverIsActive())
        {
            ExecuteScreenSaverMode();
        }
    }
}

static void ExecuteReadingErrorMCAStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *p_current_phase)
{
//    if (!ScreenSaverIsActive())
//    {
//        //Display message on LCD                       
//        DisplayText("   MOUTH", g_display_xpos , g_display_ypos_1_4);
//        DisplayText("    PIECE", g_display_xpos, g_display_ypos_2_4);
//        DisplayText(" READING", g_display_xpos , g_display_ypos_3_4);
//        DisplayText("    ERROR", g_display_xpos, g_display_ypos_4_4);
//    }
    
    if(ScreenShouldBeBlank())
    {
        EnterUIState(p_current_phase, STANDBY_STATE, IMAGE_1, 0);
    }    
    else if (hw_wdog_status & STARTUP_ERROR)
    {
        EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1,
                        hw_wdog_status & STARTUP_ERROR);
    }
    else if ((hw_wdog_status & MOUTHPIECE_ATTACHED) == 0)
    {
        // Wait in this state until Mouthpiece removed (== 0)
        // There is an error with MCA and must be removed to continue
        EnterUIState(p_current_phase, INSERT_MCA_STATE, IMAGE_1, 0);
    }
    else if (!EnterErrorStateIfBistFails(p_current_phase, false))
    {
        /* No error was detected, so we proceed normally, i.e. wait for
         * the button to be pressed and execute screensaver ops as needed */
        if (PushbuttonPressed(PUSHBUTTON_1))
        {
            // Return to same state, resetting the display and screensaver timer
            EnterUIState(p_current_phase, *p_current_phase, IMAGE_1, 0);
        }
        if (ScreenSaverIsActive())
        {
            ExecuteScreenSaverMode();
        }
    }
}

static void ExecuteExpiredMCAStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *p_current_phase)
{
    if (!ScreenSaverIsActive())
    {
        //Display message on LCD                       
        //DisplayText("MOUTHPIECE", g_display_xpos, g_display_ypos_1_2);
        //DisplayText(" EXPIRED", g_display_xpos, g_display_ypos_2_2);
    }
        
    if(ScreenShouldBeBlank())
    {
        EnterUIState(p_current_phase, STANDBY_STATE, IMAGE_1, 0);
    }    
    else if (hw_wdog_status & STARTUP_ERROR)
    {
        EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1,
                        hw_wdog_status & STARTUP_ERROR);
    }
    else if ((hw_wdog_status & MOUTHPIECE_ATTACHED) == 0)
    {
        // Wait in this state until Mouthpiece removed (== 0)
        // There is an error with MCA and must be removed to continue
        EnterUIState(p_current_phase, INSERT_MCA_STATE, IMAGE_1, 0);
    }
    else if (!EnterErrorStateIfBistFails(p_current_phase, false))
    {
        /* No error was detected, so we proceed normally, i.e. wait for
         * the button to be pressed and execute screensaver ops as needed */
        if (PushbuttonPressed(PUSHBUTTON_1))
        {
            // Return to same state, resetting the display and screensaver timer
            EnterUIState(p_current_phase, *p_current_phase, IMAGE_1, 0);
        }
        if (ScreenSaverIsActive())
        {
            ExecuteScreenSaverMode();
        }
    }
}

/*
 * This state function gets execute if the MCA is tried to be used
 * within the 12 hour window.
 */

static void ExecuteMCAPeriodStateEvents(uint16_t hw_wdog_status, 
                                      ui_state_t *p_current_phase)
{
    if(ScreenShouldBeBlank())
    {
        EnterUIState(p_current_phase, STANDBY_STATE, IMAGE_1, 0);
    }    
    else if (hw_wdog_status & STARTUP_ERROR)
    {
        EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1,
                        hw_wdog_status & STARTUP_ERROR);
    }
    else if ((hw_wdog_status & MOUTHPIECE_ATTACHED) == 0)
    {
        // Wait in this state until Mouthpiece removed (== 0)
        // There is an error with MCA and must be removed to continue
        EnterUIState(p_current_phase, INSERT_MCA_STATE, IMAGE_1, 0);
    }
    else if (!EnterErrorStateIfBistFails(p_current_phase, false))
    {
        /* No error was detected, so we proceed normally, i.e. wait for
         * the button to be pressed and execute screensaver ops as needed */
        if (PushbuttonPressed(PUSHBUTTON_1))
        {
            // Return to same state, resetting the display and screensaver timer
            EnterUIState(p_current_phase, *p_current_phase, IMAGE_1, 0);
        }
        if (ScreenSaverIsActive())
        {
            ExecuteScreenSaverMode();
        }
    }
}

static void ExecuteDetachedMCAStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *p_current_phase)
{
//    if (!ScreenSaverIsActive())
//    {
//        //Display message on LCD                       
//        DisplayText("   MOUTH", g_display_xpos, g_display_ypos_1_3);
//        DisplayText("    PIECE", g_display_xpos, g_display_ypos_2_3);
//        DisplayText("DETACHED", g_display_xpos, g_display_ypos_3_3);
//    }
        
    if(ScreenShouldBeBlank())
    {
        EnterUIState(p_current_phase, STANDBY_STATE, IMAGE_1, 0);
    }    
    else if (hw_wdog_status & STARTUP_ERROR)
    {
        EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1,
                        hw_wdog_status & STARTUP_ERROR);
    }
    else if (hw_wdog_status & MOUTHPIECE_ATTACHED)
    {
        if (++g_MCA_SwitchDebounceCounter > 4)
        {
            // Wait in this state until Mouthpiece is attached again. Then, read state
            g_MCA_error = false;  //clear any previous MCA error now that we are inserting a new one
            EnterUIState(p_current_phase, READING_MCA_STATE, IMAGE_1, 0);
        }
    }
    else if (!EnterErrorStateIfBistFails(p_current_phase, false))
    {
        /* No error was detected, so we proceed normally, i.e. wait for
         * the button to be pressed and execute screensaver ops as needed */
        if (PushbuttonPressed(PUSHBUTTON_1))
        {
            // Return to same state, resetting the display and screensaver timer
            EnterUIState(p_current_phase, *p_current_phase, IMAGE_1, 0);
        }
        if (ScreenSaverIsActive())
        {
            ExecuteScreenSaverMode();
        }
    }
}

/*  The application iterates through this function while in the 
 *  Reading MCA state.
 * 
 *  Parameters:
 *    hw_wdog_status:   Bitflags for hardware watchdog results
 *    p_current_phase:  Pointer used for updating the current state
 *                       as needed
 */
static void ExecuteReadingMCAStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *p_current_phase)
{
    uint8_t MCAStatus;
    uint16_t timer;
    uint16_t ndx, i;
    bool first_minute; // Should be true within the first minute of countdown
  
    if (hw_wdog_status & STARTUP_ERROR)
    {
        EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1,
                        hw_wdog_status & STARTUP_ERROR);
    }
    else if (hw_wdog_status & MOUTHPIECE_ATTACHED)
    {
        // Changed to simply call MCAGetStatus since that's all that it does.
        MCAGetStatus(&MCAStatus);
        // Get Serial number of attached MCA
        MCAReadSerialNumber(g_MCA_SN);

        if (MCAStatus & MCA_READING_ERROR)
        {
            // If error reading EEPROM, Go to Insert Mouthpiece
            EnterUIState(p_current_phase, MCA_READING_ERROR_STATE, IMAGE_1, 0);
        }
        else if (MCAStatus & MCA_EXPIRED)
        {
            // If error MCA expired, Go to Insert Mouthpiece
            EnterUIState(p_current_phase, MCA_EXPIRED_STATE, IMAGE_1, 0);
        }
        else if (MCAStatus & MCA_PERIOD)
        {
            // If error MCA expired, Go to Insert Mouthpiece
            EnterUIState(p_current_phase, MCA_PERIOD_ERROR_STATE, IMAGE_1, 0);
        }
        else if (MCAStatus & MCA_ERROR)	// Attention, this must be bitwise operator, not logic as was before
        {
            //If there has been another error, go to the error state
            g_MCA_error = true;
            EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1, (((uint64_t)MCAStatus)<<32) | (hw_wdog_status & STARTUP_ERROR)); 
        }
        else if (g_mouthpiece_removed_during_operation && strcmp((const char*)g_MCA_SN_old, (const char*)g_MCA_SN) == 0)
        {
            // If the MCA was removed during operation, and it is the same as the one inserted before, go directly to Pause. Otherwise, verify
            EnterUIState(p_current_phase, PAUSED_STATE, IMAGE_1, 0);
            timer = GetOperationStateTimer();
            first_minute = true;
            g_ResumeFromPause = true;
            WriteImageToLCD(CLOCK_FULL_IMAGE, false, false);  // This displays the full clock tick marks.
            WriteImageToLCD(LARGE_TIME0_TEXT + timer/60, false, false);  
            ndx = ((timer % 60) ? (timer % 60) : 60);
            for (i = 59; i >= ndx; i--)
            {
                WriteImageToLCD(CNTDWN_DISPLAY_BASE + i, false, false);
            }
            WriteImageToLCD (PAUSED_TEXT_IMAGE, false, false);   // "PAUSED".
        }
        else  
        {
            // Normal state. Go to Verify SN
            EnterUIState(p_current_phase, VERIFY_SN_STATE, IMAGE_1, 0);
        }
        
        // Update previous MCA_SN
        strcpy((char*)g_MCA_SN_old,(const char*)g_MCA_SN);
    }
    else
    {
        EnterUIState(p_current_phase, INSERT_MCA_STATE, IMAGE_1, 0);
    }

}

/*  The application iterates through this function while in the 
 *  Verify SN state.
 * 
 *  Parameters:
 *    hw_wdog_status:   Bitflags for hardware watchdog results
 *    p_current_phase:  Pointer used for updating the current state
 *                       as needed
 */
static void ExecuteVerifySNStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *p_current_phase)
{
	uint16_t elapsedTherapyTime = 0;
    
    if (!ScreenSaverIsActive())
    {
        DisplayText((char *)g_MCA_SN, g_display_xpos, g_display_ypos_2_4);
    }
    
    if(ScreenShouldBeBlank())
    {
        EnterUIState(p_current_phase, STANDBY_STATE, IMAGE_1, 0);
    }    
    else if (hw_wdog_status & STARTUP_ERROR)  //Startup error = 
    {
        EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1,
                        hw_wdog_status & STARTUP_ERROR);
    }
    else if (!EnterErrorStateIfBistFails(p_current_phase, false))
    {
        /* No error was detected, so we proceed normally, i.e. wait for
         * the button to be pressed and execute screensaver ops as needed */
        if (PushbuttonPressed(PUSHBUTTON_1))
        {
            if(!ScreenSaverIsActive())
            {
                // Determine if we need to Start a New Therapy session or
                // continue with a previous but interrupted Therapy session.
                MCAReadElapsedTherapyTime (&elapsedTherapyTime);
                if (elapsedTherapyTime == 0)
                {
                    // Normal state
                    EnterUIState(p_current_phase, READY_STATE, IMAGE_1, 0);
                }
                else if (elapsedTherapyTime < MCA_THERAPY_COMPLETE_TIME)
                {
                    EnterUIState(p_current_phase, MCA_RESUME_CONFIRM_STATE, IMAGE_1, 0);
                }
            }
            else
            {
                // Wake up after pressed button
                EnterUIState(p_current_phase, READING_MCA_STATE, IMAGE_1, 0);
            }
        }
        else if ((hw_wdog_status & MOUTHPIECE_ATTACHED) ==0)
        {
            //EnterUIState(p_current_phase, MCA_DETACHED_STATE, IMAGE_1, 0);
            // If Mouthpiece is removed, let's go back to the
            // "Insert Mouthpiece" state.
            EnterUIState(p_current_phase, INSERT_MCA_STATE, IMAGE_1, 0);
        }
        if (ScreenSaverIsActive())
        {
            ExecuteScreenSaverMode();
        }
    }
}

/*  The application iterates through this function while in the 
 *  ready state.
 * 
 *  Parameters:
 *    hw_wdog_status:   Bitflags for hardware watchdog results
 *    p_current_phase:  Pointer used for updating the current state
 *                       as needed
 */
static void ExecuteReadyStateEvents(uint16_t hw_wdog_status,
                                    ui_state_t *p_current_phase)
{
    uint32_t therapy_on_time;
	uint16_t elapsedTherapyTime = 0;
    uint32_t currentTime, MCA_LastTherapyTime;
    
//    if (!ScreenSaverIsActive())
//    {
//        //Display message on LCD                       
//        DisplayText("   READY"          , g_display_xpos, g_display_ypos_1_2);
//        
//        char p_String[8];
//        strcpy(p_String,"   Press ");
//        // strcat(p_String, (char *)31);
//        p_String[9] = 31;
//        p_String[10] = '\0';
//        
//        DisplayText(p_String            , g_display_xpos, g_display_ypos_2_2);
//    }
        
    if(ScreenShouldBeBlank())
    {
        EnterUIState(p_current_phase, STANDBY_STATE, IMAGE_1, 0);
    }    
    else if (hw_wdog_status & STARTUP_ERROR)
    {
        EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1, hw_wdog_status & STARTUP_ERROR);
    }
    else if ((hw_wdog_status & MOUTHPIECE_ATTACHED)==0)
    {
        //EnterUIState(p_current_phase, MCA_DETACHED_STATE, IMAGE_1, 0);
        // If Mouthpiece is removed, let's go back to the
        // "Insert Mouthpiece" state.
        EnterUIState(p_current_phase, INSERT_MCA_STATE, IMAGE_1, 0);
    }
    else if (!EnterErrorStateIfBistFails(p_current_phase, false))
    {
        // We execute this if BIST did not generate any errors
        if (ScreenSaverIsActive())
        {
            if (PushbuttonPressed(PUSHBUTTON_1))
            {
                // Return to Reading state after waking up
                EnterUIState(p_current_phase, READING_MCA_STATE, IMAGE_1, 0);
            }      
            ExecuteScreenSaverMode();
        }
        else if (PushbuttonPressed(PUSHBUTTON_1))
        {
            //uint32_t therapy_on_time = ReadUISetting(OPERATION_STATE, SPARE0);
            therapy_on_time = 5 * 60;  // 5 minutes in seconds.
            MCAReadElapsedTherapyTime (&elapsedTherapyTime);
            // We should only have to check for a time if therapy was started
            // and not completed.
            if (elapsedTherapyTime != MCA_THERAPY_COMPLETE_TIME)
                therapy_on_time = MCA_THERAPY_COMPLETE_TIME - elapsedTherapyTime;
            
#ifdef USE_SHORT_THERAPY_TIME
            therapy_on_time = 30;
#endif
            EnterUIState(p_current_phase, OPERATION_STATE, IMAGE_2,
                            therapy_on_time/60);
            RTCCGetTimestamp(&currentTime);
            MCAReadTimeStamp(&MCA_LastTherapyTime);
            if ((currentTime - MCA_LastTherapyTime) > (uint32_t)MCA_TIME_LIMIT)  // 12 hours in seconds.
            {
                MCAWriteTimeStamp (currentTime);
            }
            WriteLEDCurrent(((float) g_specified_LED_current)/1000.0, false); 
            // Update MCA with current LCU time, if appropriate.

            // Set number of seconds of operation
            StartOperationStateCountdown(therapy_on_time);
            //StartOperationStateCountdown(ReadUISetting(OPERATION_STATE, SPARE0));
            /*  Elsewhere in the code, g_most_recent_update_time is used to
             *  determine which clock ticks need to be erased. If the 
             *  therapy time is an even multiple of 60 (i.e. an even number
             *  of minutes) then we start with a complete dial image.
             *  Otherwise, we start with that same complete dial but erase
             *  the first 60 - (therapy_on_time % 60) tick marks before
             *  counting down.
             * 
             *  To ensure that our routines know to erase these initial tick
             *  marks, we first add a full minute to the therapy time. This has
             *  the effect of erasing the tick marks in question, as one can
             *  determine by analyzing the code.  */
            g_most_recent_update_time = ((therapy_on_time % 60) == 0 ?
                therapy_on_time : (therapy_on_time + 60));
        }
    }
}

/*
 This state is entered when the MCA is trying to recover from an
 operation that was interrupted by a power cycle.
 */
static void ExecuteResumeMCAStateEvents(uint16_t hw_wdog_status,
                                      ui_state_t *p_current_phase)
{
    uint32_t therapy_on_time;
	uint16_t elapsedTherapyTime = 0;
    uint32_t currentTime, MCA_LastTherapyTime;
    
    if(ScreenShouldBeBlank())
    {
        EnterUIState(p_current_phase, STANDBY_STATE, IMAGE_1, 0);
    }    
    else if (hw_wdog_status & STARTUP_ERROR)
    {
        EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1, hw_wdog_status & STARTUP_ERROR);
    }
    else if ((hw_wdog_status & MOUTHPIECE_ATTACHED)==0)
    {
        //EnterUIState(p_current_phase, MCA_DETACHED_STATE, IMAGE_1, 0);
        // If Mouthpiece is removed, let's go back to the
        // "Insert Mouthpiece" state.
        EnterUIState(p_current_phase, INSERT_MCA_STATE, IMAGE_1, 0);
    }
    else if (!EnterErrorStateIfBistFails(p_current_phase, false))
    {
        // We execute this if BIST did not generate any errors
        if (ScreenSaverIsActive())
        {
            if (PushbuttonPressed(PUSHBUTTON_1))
            {
                // Return to Reading state after waking up
                EnterUIState(p_current_phase, READING_MCA_STATE, IMAGE_1, 0);
            }      
            ExecuteScreenSaverMode();
        }
        else if (PushbuttonPressed(PUSHBUTTON_1))
        {
            //uint32_t therapy_on_time = ReadUISetting(OPERATION_STATE, SPARE0);
            therapy_on_time = 5 * 60;  // 5 minutes in seconds.
            MCAReadElapsedTherapyTime (&elapsedTherapyTime);
            // We should only have to check for a time if therapy was started
            // and not completed.
            if (elapsedTherapyTime != MCA_THERAPY_COMPLETE_TIME)
                therapy_on_time = MCA_THERAPY_COMPLETE_TIME - elapsedTherapyTime;
            
#ifdef USE_SHORT_THERAPY_TIME
            therapy_on_time = 30;
#endif
            EnterUIState(p_current_phase, OPERATION_STATE, IMAGE_2,
                            therapy_on_time/60);
            RTCCGetTimestamp(&currentTime);
            MCAReadTimeStamp(&MCA_LastTherapyTime);
            if ((currentTime - MCA_LastTherapyTime) > (uint32_t)MCA_TIME_LIMIT)  // 12 hours in seconds.
            {
                MCAWriteTimeStamp (currentTime);
            }
            WriteLEDCurrent(((float) g_specified_LED_current)/1000.0, false); 
            // Update MCA with current LCU time, if appropriate.

            // Set number of seconds of operation
            StartOperationStateCountdown(therapy_on_time);
            //StartOperationStateCountdown(ReadUISetting(OPERATION_STATE, SPARE0));
            /*  Elsewhere in the code, g_most_recent_update_time is used to
             *  determine which clock ticks need to be erased. If the 
             *  therapy time is an even multiple of 60 (i.e. an even number
             *  of minutes) then we start with a complete dial image.
             *  Otherwise, we start with that same complete dial but erase
             *  the first 60 - (therapy_on_time % 60) tick marks before
             *  counting down.
             * 
             *  To ensure that our routines know to erase these initial tick
             *  marks, we first add a full minute to the therapy time. This has
             *  the effect of erasing the tick marks in question, as one can
             *  determine by analyzing the code.  */
            g_most_recent_update_time = ((therapy_on_time % 60) == 0 ?
                therapy_on_time : (therapy_on_time + 60));
        }
    }
}

/*  The application iterates through this function while in the 
 *  operation state.
 * 
 *  Parameters:
 *    hw_wdog_status:   Bitflags for hardware watchdog results
 *    p_current_phase:  Pointer used for updating the current state
 *                       as needed
 */
static void ExecuteOperationStateEvents(uint16_t hw_wdog_status,
                                        ui_state_t *p_current_phase)
{
    static uint16_t consec_low_current_detections = 0;
    // 5/2/22 GChop. I increased the iterations from 2 to 16 because
    // the low current error was superceding the mouthpiece disconnected
    // status and not allowing the system to continue normally.
    // "5" and "8" were also too short, "10" is marginal on my prototype
    // unit.
    const uint16_t MAX_LOW_CURRENT_DETECTIONS = 16; // 2; // Max allowed before
                                                   // we treat this as an error
    const uint16_t OPERATION_ERROR = (BASIC_DEVICE_READY_ERROR |
            CURRENT_SOURCE_FAULT | CURRENT_TOO_HIGH | CURRENT_TOO_LOW);
    uint16_t completedTherapies;
    bool MCAReadingSuccess;
    
    if ((hw_wdog_status & MOUTHPIECE_ATTACHED) == 0)
    {
        g_mouthpiece_removed_during_operation = true;
        consec_low_current_detections = 0;
        PauseOperationStateCountdown();
        EnterUIState(p_current_phase, MCA_DETACHED_STATE, IMAGE_1, 0);
    }
    else if (hw_wdog_status & OPERATION_ERROR)
    {
        // Work around situation where error occurs solely because
        // CURRENT_TOO_LOW is asserted as mouthpiece is removed.
        // Here we require multiple consecutive CURRENT_TOO_LOW
        // conditions before treating this as an error.
        if ((hw_wdog_status & CURRENT_TOO_LOW) != 0) 
        {
            if (++consec_low_current_detections == MAX_LOW_CURRENT_DETECTIONS)
            {
                BlankOutDisplay(false); // Blackground to remove the clock in Errors
                EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1, CURRENT_TOO_LOW);
            }
            else 
            {   // Ignore CURRENT_TOO_LOW and process any remaining errors
                hw_wdog_status &= ~CURRENT_TOO_LOW;
                if ((hw_wdog_status & OPERATION_ERROR) != 0)
                {
                    BlankOutDisplay(false); // Blackground to remove the clock in Errors
                    EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1,
                            hw_wdog_status & OPERATION_ERROR);
                }
            }
        }
        else
        {
            BlankOutDisplay(false); // Blackground to remove the clock in Errors
            EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1, hw_wdog_status & OPERATION_ERROR);
        }
    }
    else 
    {
        /* Do NOT call EnterErrorStateIfBistFails()!  This uses the
         * BIST interval timer, and while in the operation state,
         * we want to use the display update timer instead.  This
         * simplifies the code flow, since their periods are the same. */
        consec_low_current_detections = 0;
        uint16_t timer;
        bool first_minute; // Should be true within the first minute of countdown
        if (PushbuttonPressed(PUSHBUTTON_1))
        {
            WriteLEDCurrent(0.0, true);
            PauseOperationStateCountdown();
            // Pass number of whole minutes remaining as final parameter
            EnterUIState(p_current_phase, PAUSED_STATE, IMAGE_1,
                    GetOperationStateTimer()/60);
        }
        else if (TimeToUpdateDisplay(&timer, &first_minute))
        {
            if (timer > 0)
            {
                /* Take advantage of the fact that we need to perform
                 * BIST once per second, the same rate at which the
                 * clock display is updated  */
                uint16_t bist_results;
                TestBIST(1, &bist_results, false);
                //Update the MCA usage time, once per second
                MCAReadingSuccess = MCAIncrementWriteElapsedTherapyTime();
                            
                if (((bist_results & BIST_REQUIREMENTS) == BIST_REQUIREMENTS) && MCAReadingSuccess)
                {
                    UpdateTimerDisplay(timer, first_minute);
                }
                else if (((bist_results & LED_CURRENT_ACCURATE) == 0) && OperationCountDownNewlyRestarted())
                {
                    UpdateTimerDisplay(timer, first_minute);
                }
                else if (!MCAReadingSuccess)
                {
                    // g_MCA_error = true;
                    // EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1, (((uint64_t)MCA_READING_ERROR)<<32) | (hw_wdog_status & STARTUP_ERROR)); 
                    EnterUIState(p_current_phase, MCA_READING_ERROR_STATE, IMAGE_1, 0);
                }
                else
                {
                    EnterErrorStateFromBIST(p_current_phase, bist_results);      
                }
            }
            else
            {
                WriteLEDCurrent(0.0, false);
                EnterUIState(p_current_phase, THERAPY_COMPLETE_STATE, IMAGE_1, 0);
                // Update the MCA EEPROM's Completed Therapies counter.
                MCAReadCompletedTherapies (&completedTherapies);
                ++completedTherapies;
                MCAWriteCompletedTherapies (completedTherapies);
                MCAWriteElapsedTherapyTime (MCA_THERAPY_COMPLETE_TIME);
                g_ResumeFromPause = false;
            }
        }
    }
}

/*  The application iterates through this function while in the 
 *  therapy complete state.
 * 
 *  Parameters:
 *    hw_wdog_status:   Bitflags for hardware watchdog results
 *    p_current_phase:  Pointer used for updating the current state
 *                       as needed
 */
static void ExecuteTherapyCompleteStateEvents(uint16_t hw_wdog_status,
                                              ui_state_t *p_current_phase)
{
    const uint16_t THERAPY_COMPLETE_ERROR =
        (THERMISTOR_TEMP_TOO_HIGH | HW_DETECTED_ERROR | SW_WDOG_TIMEOUT);
        
    if (!ScreenSaverIsActive())
    {
//        //Display message on LCD                       
//        DisplayText("  THERAPY", g_display_xpos, g_display_ypos_1_2);
//        DisplayText(" COMPLETE", g_display_xpos, g_display_ypos_2_2);
        WriteImageToLCD (2010, false, false);   // "Therapy Complete" bmp
    }

    if(ScreenShouldBeBlank())
    {
        EnterUIState(p_current_phase, STANDBY_STATE, IMAGE_1, 0);
    }    
    else if (hw_wdog_status & THERAPY_COMPLETE_ERROR)
    {
        if (ScreenSaverIsActive())
        {
            /* Erase screen so that the error message isn't displayed
             * on top of the screensaver image */
            BlankOutDisplay(false);
        }
        EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1, hw_wdog_status & THERAPY_COMPLETE_ERROR);
    }
    else if ((hw_wdog_status & MOUTHPIECE_ATTACHED) == 0)
    {
        EnterUIState(p_current_phase, INSERT_MCA_STATE, IMAGE_1, 0);
    }
    else if (!EnterErrorStateIfBistFails(p_current_phase, ScreenSaverIsActive()))
    {
        // We execute this if BIST did not generate any errors
        if (PushbuttonPressed(PUSHBUTTON_1))
        {
            if (!ScreenSaverIsActive())
            {
                // Return to same state, resetting the display and screensaver timer
                EnterUIState(p_current_phase, *p_current_phase, IMAGE_1, 0);
            }
            else
            {
                // If in standby, button pressed, go to Reading state
                EnterUIState(p_current_phase, READING_MCA_STATE, IMAGE_1, 0);
            }            
        }
        else if (ScreenSaverIsActive())
        {
            ExecuteScreenSaverMode();
        }
    }
}

/*  The application iterates through this function while in the 
 *  paused state.
 * 
 *  Parameters:
 *    hw_wdog_status:   Bitflags for hardware watchdog results
 *    p_current_phase:  Pointer used for updating the current state
 *                       as needed
 */
static void ExecutePausedStateEvents(uint16_t hw_wdog_status,
                                     ui_state_t *p_current_phase)
{
    if (!ScreenSaverIsActive())
    {
		// Do not show only the text with "DisplayText"
		// The screen loaded is directly the "PAUSED" image with blue background
        //DisplayText("  PAUSED", g_display_xpos, g_display_ypos_1_3);
    }
        
    if(ScreenShouldBeBlank())
    {
        EnterUIState(p_current_phase, STANDBY_STATE, IMAGE_1, 0);
    }    
    else if (hw_wdog_status & (BASIC_DEVICE_READY_ERROR | THERAPY_ON))
    {
        EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1,
                hw_wdog_status & (BASIC_DEVICE_READY_ERROR | THERAPY_ON));
    }
    else if ((hw_wdog_status & MOUTHPIECE_ATTACHED) == 0)
    {
        // If Mouthpiece removed, and no 
        g_mouthpiece_removed_during_operation = true;
        // EnterUIState(p_current_phase, STANDBY_STATE, IMAGE_1, 0);    // <- Never use this state STANDBY_STATE (Only Screensaver)
        EnterUIState(p_current_phase, MCA_DETACHED_STATE, IMAGE_1, 0);  //[CHANGE NOT REQUIERED]    //todohere
    }
    else if (!EnterErrorStateIfBistFails(p_current_phase, ScreenSaverIsActive()))
    {
        // We execute this if BIST did not generate any errors
        if (ScreenSaverIsActive())
        {
            if (PushbuttonPressed(PUSHBUTTON_1))
            {
                // Go to ready state, since mouthpiece has not been removed
                EnterUIState(p_current_phase, READY_STATE, IMAGE_1, 0);     
            }
            else 
            {
                ExecuteScreenSaverMode();
            }
        }
        else if (PushbuttonPressed(PUSHBUTTON_1))  // Unpause the device
        {
            g_mouthpiece_removed_during_operation = false;
            EnterUIState(p_current_phase, OPERATION_STATE, IMAGE_2, g_most_recent_update_time/60);
            WriteLEDCurrent(((float) g_specified_LED_current)/1000.0, false); 
            __delay_ms(20);
            
            g_most_recent_update_time = ((g_most_recent_update_time % 60) == 0 ?
                g_most_recent_update_time : (g_most_recent_update_time + 60));
            
            WriteImageToLCD(ReadUISetting(PAUSED_STATE, IMAGE_2) + MAX_NUM_MINUTES + 1, false, false);
            WriteImageToLCD (2009, false, false);
            ResumeOperationStateCountdown();
        }
    }    
}

/*  The application iterates through this function while in the 
 *  error state.
 * 
 *  Parameters:
 *    hw_wdog_status:   Bitflags for hardware watchdog results
 *    p_current_phase:  Pointer used for updating the current state
 *                       as needed
 */
static void ExecuteErrorStateEvents(uint16_t hw_wdog_status,
                                    ui_state_t *p_current_phase)
{
     /* Clear the pushbutton status. This ensures that if the button
     * is pressed, the device will not act upon this button press upon
     * emerging from the error state. */
    PushbuttonPressed(PUSHBUTTON_1);
    
    if (g_mouthpiece_removed_during_operation)
    {
        if (hw_wdog_status & MOUTHPIECE_ATTACHED)
        {
            ui_state_t next_state = ScreenSaverIsActive() ? READY_STATE : PAUSED_STATE;
            EnterUIState(p_current_phase, next_state, IMAGE_1, GetOperationStateTimer()/60);
            g_mouthpiece_removed_during_operation = false;
        }
        else if (ScreenSaverIsActive())
        {
            /*  Most of the time, the screensaver would be disabled during
             *  the error state. The only exception is when the error was
             *  caused by a mouthpiece removal.  */
            ExecuteScreenSaverMode();
        }
    }
    //if the error is due to the MCA then this can be cleared by removing the MCA
    else if (g_MCA_error)
    {
        if (!(hw_wdog_status & MOUTHPIECE_ATTACHED))
        {
            EnterUIState(p_current_phase, INSERT_MCA_STATE, IMAGE_1, 0);
        }
    }
    // Otherwise, if error was not caused by mouthpiece being removed
    // during usage, we can only recover with a complete reboot
}

/*
 *   To be used during the operation state to update the clock display
 *   on the LCD.  This will typically require painting a single clock tick
 *   image, but it will occasionally require redrawing the entire clock dial
 *   and updating the number of minutes remaining.
 * 
 *   Parameters;    timer: Number of seconds remaining
 *                  first_minute: 'true' if we are within the first minute
 *                    of execution; false otherwise. This determines whether
 *                    we need to redraw the clock dial image at the top
 *                    of each minute.
 */
static void UpdateTimerDisplay(uint16_t timer, bool first_minute)
{
    uint16_t ndx = ((timer % 60) ? (timer % 60) : 60);
    switch (ndx)
    {
        case 60:
            /* If the number of seconds left is evenly divisible by 60 AND
               we are within the first minute, don't load the clock image
               or the number of minutes. These should have already been
               loaded upon entering the operation state. */
            if (!first_minute)
            {
                WriteImageToLCD(ReadUISetting(OPERATION_STATE, IMAGE_1), false, false);  
                WriteImageToLCD(ReadUISetting(OPERATION_STATE, IMAGE_2) + timer/60, false, false);  
            }
            break;
        case 59:
            /* Update the numeral display at one second
               past each whole minute mark. */
            WriteImageToLCD(ReadUISetting(OPERATION_STATE, IMAGE_2) + timer/60, false, false);  
            /* Fall through to next case to update the
               tick mark display */
        default:
            UpdateTimerDial(timer);
            break;
    }
    g_most_recent_update_time = timer;
}

/*  
 *  When the pushbutton is pressed repeatedly, several seconds can elapse
 *  between the time that the device is initially paused and the time
 *  that the display is actually updated. This function takes that into
 *  account, erasing multiple clock tick marks as needed. If necessary,
 *  the entire clock display is regenerated.
 */
static void UpdateTimerDial(uint16_t timer)
{
    //char myString[64];
    
    //sprintf (myString, "UpdateTimerDial timer = %d  g_MRUT = %d g_RFP = %d\n", timer, g_most_recent_update_time, g_ResumeFromPause);
    //printf (myString);
    
    if (((g_most_recent_update_time-1)/60 == timer/60) || g_ResumeFromPause)
    {
        /* The most recent update time and the current time are
         * within the same minute.  Only erase the required tick marks. */
        uint16_t start_tick = 
            ((g_most_recent_update_time % 60) ? (g_most_recent_update_time % 60) : 60) - 1;
        uint16_t i;
        //sprintf (myString, "@1373, ST = %d\n", start_tick);
        //printf (myString);
        for (i=start_tick; i>=(timer % 60); i--)
        {
            WriteImageToLCD(CNTDWN_DISPLAY_BASE + i, false, false); 
        }
    }
    else
    {
        /* We must redraw the entire dial and then erase tick
         * marks starting at #59 */
        WriteImageToLCD(ReadUISetting(OPERATION_STATE, IMAGE_1), false, false);  
        WriteImageToLCD(ReadUISetting(OPERATION_STATE, IMAGE_2) + timer/60, false, false);  
        uint16_t ndx = ((timer % 60) ? (timer % 60) : 60);
        uint16_t i;
        //sprintf (myString, "@1390, ndx = %d\n", ndx);
        //printf (myString);
        for (i=59; i>=ndx; i--)
        {
            WriteImageToLCD(CNTDWN_DISPLAY_BASE + i, false, false);
        }
    }
}


/*
 *  aux_info:  State-specific value used for loading additional images
 *             or performing other operations as necessary
 *             When entering ERROR_STATE, aux_info has this definition:
 *             aux_info[63:48]     unassigned
 *             aux_info[47:32]     system_status with bit definition defined in this file
 *             aux_info[31:16]     selftest_status with bit definition defined in Test_Functions.h
 *             aux_info[15:0]      hw_wdog_status with bit definition defined in hw_watchdog.h
 * 
 *               * The self-test bits should be set to 1 if the corresponding
 *                 test passes or unnecessary. This requires modifying the
 *                 raw POST and BIST results.
 *               * The hardware watchdog results should be masked such that
 *                 they only indicate the conditions that are relevant for
 *                 the current phase (i.e. whichever one is indicated by
 *                 p_current_phase). 
 * 
 *             When entering the OPERATION_STATE, aux_info has this definition:
 *             aux_info[6:0]   minutes in clock image
 */
static void EnterUIState(ui_state_t *p_current_phase, ui_state_t next_phase,
                         ui_setting_t img_setting, uint64_t aux_info)
{
    char error_message[32];
    
    WriteRGBLED(LED_CUSTOM, ReadUISetting(next_phase, COLOR_1_R),
                            ReadUISetting(next_phase, COLOR_1_TIME),
                            ReadUISetting(next_phase, COLOR_2_R),
                            ReadUISetting(next_phase, COLOR_2_TIME));
    /* Screen may have been blanked out by screensaver, so always turn screen
     * on when changing states. Do this by disabling the screen saver.  It
     * will be re-enabled later as necessary. */ 
    DisableScreenSaver();
    // Turn backlight on after loading images. See comments below.
    
    // Perform state-specific operations as needed
    switch (next_phase)
    {
        case POWER_UP_STATE:
            WriteImageToLCD(ReadUISetting(next_phase, img_setting), true, false);
            // Don't re-enable screensaver during power-up phase
            break;
        case INSERT_MCA_STATE:
            WriteImageToLCD(ReadUISetting(next_phase, img_setting), true, false);
            WriteImageToLCD(2000, false, false);
            EnableScreenSaver();
            break;
        case ERROR_STATE:
            // Turn current off just in case not already done
            WriteLEDCurrent(0.0, false);
            if (ScreenSaverIsActive())
            {
                // Replace screensaver background with dark background
                // suitable for error message
                BlankOutDisplay(false);
                DisableScreenSaver();
            }
            /* Load error-specific images here.
             * In this case, the upper 16 bits contain the BIST results
             * (as applicable) and the lower 16 bits contain the hardware
             *  watchdog results (again, as applicable). */  
            if (aux_info == 0)  //if there is no aux info, give a generic "unknown error" message
            {                
                // Write white background
                WriteImageToLCD(ReadUISetting(next_phase, IMAGE_1), true, false);

                // Display message on LCD                       
                DisplayText(" CONTROL", g_display_xpos, g_display_ypos_1_3);
                DisplayText("     UNIT" , g_display_xpos, g_display_ypos_2_3);
                sprintf(error_message, " ERROR %02d", (uint16_t)ERROR_IMG_UNKNOWN);
                DisplayText(error_message, g_display_xpos, g_display_ypos_3_3);
    
            }
            // For self-tests (POST or BIST), the upper 16 bits should each
            // be set to 0 at this point if all tests were passed.  A '1'
            // indicates some type of error.
            else if (aux_info != 0)   //aux_info indicates what type of error message to display
            {
                //Write the appropriate error message to the LCD based on aux_info
                if (DisplayTestResultsByPriority((aux_info & 0x00000000FFFF0000) >> 16, aux_info & 0x000000000000FFFF, aux_info >> 32)
                        == ERROR_MOUTHPIECE_DETACHED)
                {
                    /*  Only re-enable the screensaver if the error condition
                     *  reported is that the mouthpiece was detached. */
                    EnableScreenSaver();
                }
            }
            // Also display overlay indicating number of minutes remaining, unless error is an MCA error
            // We can't use aux_info to pass the number of minutes
            // remaining, so we have to extract that info ourselves here
            if(!g_MCA_error)
            {
                // WriteImageToLCD(ReadUISetting(PAUSED_STATE, IMAGE_2) + GetOperationStateTimer()/60, false, false); //[CHANGE NOT REQUIERED] //todohere 
            }
            break;
        case OPERATION_STATE:
            DisableScreenSaver();
            // Read most recently stored specified current in EEPROM and multiply it by the MCA calibration factor
            uint16_t MCACalibration;
            MCAReadCalibration(&MCACalibration);
            g_specified_LED_current =  ReadLEDBoardSpecifiedCurrent() * ((float)MCACalibration/((float)32768));
            
            if (img_setting == IMAGE_2)
            {
                if (!g_ResumeFromPause)
                {
                    //Write whole clock image
                    WriteImageToLCD(ReadUISetting(next_phase, IMAGE_1), false, false);  
                    // This only updates the minutes numeral within the clock dial
                    WriteImageToLCD(ReadUISetting(next_phase, img_setting) + aux_info, false, false);  
                }
            }
            break;
        case STANDBY_STATE: 
            // The StandBy is the START CASE after 1h inactivity
            // Turn current off just in case not already done
            WriteLEDCurrent(0.0, false);
            // WriteImageToLCD(ReadUISetting(next_phase, img_setting), false, false);  // No Image
            BlankOutDisplay(true);
            // EnableScreenSaver();
            break; 
        case READING_MCA_STATE: 
            WriteImageToLCD(ReadUISetting(next_phase, img_setting), true, false);
            WriteImageToLCD(2001, false, false);
            EnableScreenSaver();
            break; 
        case VERIFY_SN_STATE: 
            WriteImageToLCD(ReadUISetting(next_phase, img_setting), true, false);
            WriteImageToLCD(2002, false, false);
            EnableScreenSaver();
            break; 
        case READY_STATE:
            // Clear the pushbutton status. This ensures that we only start
            // operation if the button has been pressed after entering
            // the ready state.
            PushbuttonPressed(PUSHBUTTON_1);
            WriteImageToLCD(ReadUISetting(next_phase, img_setting), true, false);
            WriteImageToLCD(2003, false, false);
            EnableScreenSaver();
            break; 
        case MCA_RESUME_CONFIRM_STATE:
            PushbuttonPressed(PUSHBUTTON_1);
            WriteImageToLCD(ReadUISetting(next_phase, img_setting), true, false);
            WriteImageToLCD(PRESS_TO_RESUME_IMAGE, false, false);
            EnableScreenSaver();
            break;
        case PAUSED_STATE:
            //WriteImageToLCD(ReadUISetting(next_phase, img_setting), true, false);
            // Also display overlay indicating number of minutes remaining
            //WriteImageToLCD(ReadUISetting(PAUSED_STATE, IMAGE_2) + aux_info, false, false);
            WriteImageToLCD (2008, false, false);
            EnableScreenSaver();
            break; 
        case THERAPY_COMPLETE_STATE: 
            WriteImageToLCD(ReadUISetting(next_phase, img_setting), true, false);
            EnableScreenSaver();
            break; 
        case MCA_DETACHED_STATE:  
            g_MCA_SwitchDebounceCounter = 0;
            //WriteImageToLCD(ReadUISetting(next_phase, img_setting), true, false);
            WriteImageToLCD(2005, true, false);    // Red Box 
            WriteImageToLCD(2007, false, false);    // "MOUTHPIECE DETACHED, Reinsert Mouthpiece"
            EnableScreenSaver();
            break;
        case MCA_READING_ERROR_STATE:
            // Turn current off just in case not already done
            WriteLEDCurrent(0.0, false);
            //WriteImageToLCD(ReadUISetting(next_phase, img_setting), true, false); 
            WriteImageToLCD(2005, true, false);    // Red Box 
            WriteImageToLCD(2004, false, false);    // "Reading Error, Re-insert Mouthpiece"
            EnableScreenSaver();
            break;
        case MCA_EXPIRED_STATE:
            //WriteImageToLCD(ReadUISetting(next_phase, img_setting), true, false);
            WriteImageToLCD(2005, true, false);    // Red Box 
            WriteImageToLCD(2006, false, false);   // "MOUTHPIECE EXPIRED"
            EnableScreenSaver();
            break;
        case MCA_PERIOD_ERROR_STATE:
            WriteImageToLCD(2005, true, false);    // Red Box 
            WriteImageToLCD(2011, false, false);   // "MOUTHPIECE DAILY LIMIT REACHED"
            EnableScreenSaver();
            break;
        default: 
            WriteImageToLCD(ReadUISetting(next_phase, img_setting), true, false);  
            EnableScreenSaver();
            break; 
    }
    

    *p_current_phase = next_phase;
}


/*
 *   If an error was detected during BIST, use this fucntion to enter
 *   the error state.  This function performs some necessary pre-processing
 *   on the BIST results so as to comply with the EnterUIState() parameter
 *   protocol.
 */
static void EnterErrorStateFromBIST(ui_state_t *p_current_phase, uint16_t bist_results)
{
    /*  The 'aux_info' parameter in EnterUIState() should
     *  have a '1' bit for each of the self-test (POST or BIST)
     *  results that passed.  To prevent false errors, we should
     *  assign a '1' result to each of the tests that are not
     *  part of the BIST requirements.    */
    uint16_t test_results = (bist_results & BIST_REQUIREMENTS) |
                ~BIST_REQUIREMENTS;
    /*  Now toggle each of these bits to comply with how 
     *  'aux_info' parameter is used within EnterUIState(). */
    test_results ^= 0xFFFF;
    EnterUIState(p_current_phase, ERROR_STATE, IMAGE_1, 
            ((uint32_t) test_results) << 16);   
}

/*
 *   Returns 'true' if a BIST failure occurs and we must
 *   enter the error state. Returns 'false' otherwise.
 */
static bool EnterErrorStateIfBistFails(ui_state_t *p_current_phase,
                                       bool replace_power_up_screen)
{
    static uint16_t consec_current_level_errors = 0;
    const uint16_t MAX_CURRENT_LVL_ERR_DETECTIONS = 2; // Max allowed before
                                                  // we treat this as an error

    bool failure = false;
    
    if (TimeToPerformBIST())
    {
        uint16_t bist_results;
        TestBIST(1, &bist_results, false);
        // Mask off any current level errors unless a sufficient
        // number have been consecutively detected
        if ((bist_results & LED_CURRENT_ACCURATE) == 0)
        {
            if (consec_current_level_errors++ < MAX_CURRENT_LVL_ERR_DETECTIONS)
            {
                bist_results |= LED_CURRENT_ACCURATE;
            }                
        }
        else
        {
            consec_current_level_errors = 0;
        }
        
        if ((bist_results & BIST_REQUIREMENTS) != BIST_REQUIREMENTS)
        {
            failure = true;
            if (replace_power_up_screen)
            {
                WriteImageToLCD(ReadUISetting(POWER_UP_STATE, IMAGE_2), false, false);  
            }
            BlankOutDisplay(false);
            EnterErrorStateFromBIST(p_current_phase, bist_results);  
        }
        else
        {
            consec_current_level_errors = 0;
        }
    }
    return failure;
}

/*
 *   Returns the error index that corresponds to the highest priority issue
 *   reported within the bitflags of the three parameters.  If any error 
 *   conditions are to be ignored, their corresponding bitflags must be
 *   masked off before being passed into this function. 
 * 
 *   selftest_status bit assignments are defined in Test_Functions.h
 *   watchdog_status bit assignments are defined in hw_watchdog.h
 *   system_status bit assignments are defined in this file
 *   error_index_t is defined in this file
 * 
 * 
 * 
 */
static error_index_t DisplayTestResultsByPriority(uint16_t selftest_status, uint16_t watchdog_status, uint16_t system_status)
{
    /* 
     *  NOTE: To simplify the higher-level functions, the self-test bitflags 
     *  must be inverted before they are passed into this function.  The
     *  corresponding logic must therefore be reversed, e.g. 
     *  (selftest_status & FAN_WORKS) actually indicates a fan failure
     *  rather than proper operation.
     */
 
    error_index_t ndx = ERROR_UNKNOWN;
    error_image_index_t ndx_image = ERROR_IMG_UNKNOWN;
    
    char error_message[10];
    
    if (watchdog_status & MOUTHPIECE_ATTACHED)
    {
        ndx = ERROR_MOUTHPIECE_DETACHED;
    }
    else if (selftest_status & I2C_DIDNT_TIMEOUT)
    {
        ndx = ERROR_I2C; 
        ndx_image = ERROR_IMG_I2C; 
    }
    else if (selftest_status & CTRL_BOARD_TEMP_WORKS)
    {
        ndx = ERROR_TEMP_TOO_HIGH; 
        ndx_image = ERROR_IMG_TEMP_TOO_HIGH; 
    }
    else if (watchdog_status & THERMISTOR_TEMP_TOO_HIGH)
    {
        ndx = ERROR_TEMP_TOO_HIGH;
        ndx_image = ERROR_IMG_TEMP_TOO_HIGH;
    }
    else if (watchdog_status & CURRENT_TOO_HIGH)
    {
        ndx = ERROR_CURRENT_TOO_HIGH;
        ndx_image = ERROR_IMG_CURRENT_TOO_HIGH;
    }
    else if (selftest_status & FAN_WORKS)
    {
        ndx = ERROR_FAN; 
        ndx_image = ERROR_IMG_FAN; 
    }
    else if (selftest_status & SUPPLY_24VDC_VALID)
    {
        ndx = ERROR_24VDC; 
        ndx_image = ERROR_IMG_24VDC; 
    }
    else if (selftest_status & SUPPLY_5VDC_VALID)
    {
        ndx = ERROR_5VDC; 
        ndx_image = ERROR_IMG_5VDC; 
    }
    else if (selftest_status & SUPPLY_33VDC_VALID)
    {
        ndx = ERROR_33VDC; 
        ndx_image = ERROR_IMG_33VDC; 
    }
    else if (selftest_status & BATTERY_VALID)
    {
        ndx = ERROR_BATTERY; 
    }
    else if (watchdog_status & SW_WDOG_TIMEOUT)
    {
        ndx = ERROR_SOFTWARE_WATCHDOG_TIMEOUT;
        ndx_image = ERROR_IMG_SOFTWARE_WATCHDOG_TIMEOUT;
    }
    else if (selftest_status & LCD_WORKS)
    {
        ndx = ERROR_LCD; 
        ndx_image = ERROR_IMG_LCD; 
    }
    else if (selftest_status & FLASH_MEM_WORKS)
    {
        ndx = ERROR_FLASH_MEM; 
        ndx_image = ERROR_IMG_FLASH_MEM; 
    }
    else if (selftest_status & LED_BOARD_EEPROM_WORKS) 
    {
        ndx = ERROR_LED_BOARD_EEPROM; 
        ndx_image = ERROR_IMG_LED_BOARD_EEPROM; 
    }
    else if (selftest_status & LED_BOARD_TEMP_WORKS)
    {
        /* Prioritize the LED board EEPROM test over the LED board
           temperature test. That way, if the board is disconnected,
           the former error will be displayed instead of the latter. */
        ndx = ERROR_TEMP_TOO_HIGH; 
        ndx_image = ERROR_IMG_TEMP_TOO_HIGH; 
    }
    else if (selftest_status & RGB_LED_WORKS)
    {
        ndx = ERROR_RGB_LED; 
        ndx_image = ERROR_IMG_RGB_LED; 
    }
    else if (selftest_status & PUSHBUTTON_WORKS)
    {
        ndx = ERROR_PUSHBUTTON; 
        ndx_image = ERROR_IMG_PUSHBUTTON; 
    }
    else if (watchdog_status & CURRENT_TOO_LOW)
    {
        ndx = ERROR_CURRENT_TOO_LOW;
        ndx_image = ERROR_IMG_CURRENT_TOO_LOW;
    }
    else if (selftest_status & LED_CURRENT_ACCURATE)
    {
        ndx = ERROR_LED_CURRENT_INACCURATE; 
        ndx_image = ERROR_IMG_LED_CURRENT_INACCURATE; 
    }
    else if (watchdog_status & CURRENT_SOURCE_FAULT)
    {
        ndx = ERROR_CURRENT_SOURCE_FAULT;
        ndx_image = ERROR_IMG_CURRENT_SOURCE_FAULT;
    }
    else if (watchdog_status & HW_WDOG_TIMEOUT)
    {
        ndx = ERROR_HARDWARE_WATCHDOG_TIMEOUT;
        ndx_image = ERROR_IMG_HARDWARE_WATCHDOG_TIMEOUT;
    }
    else if (system_status & MCA_READING_ERROR)
    {
        ndx = ERROR_MCA_READING;
    }
    else if (system_status & MCA_EXPIRED)
    {
        ndx = ERROR_MCA_EXPIRED;
    }
    else if (system_status & MCA_PERIOD)
    {
        ndx = ERROR_MCA_PERIOD;
    }
    
    // Ignore ALARM_WORKS and START_WDOG
    // Also ignore ENABLE_HW_WDOG, but let's keep the corresponding
    // image in flash memory in case we ever need it again
    
    // If none of the aforementioned conditioned are met,
    // ndx == 0 and the error is unknown
    // WriteImageToLCD(ReadUISetting(ERROR_STATE, IMAGE_1) + (uint16_t) ndx, false, false);
    
    // Write white background
    //WriteImageToLCD(ReadUISetting(ERROR_STATE, IMAGE_1), true, false);
    WriteImageToLCD (2005, true, false);    // Draw Red Box
    // Display message on LCD                       
    DisplayText(" SYSTEM", g_display_xpos, g_display_ypos_1_2);
    //DisplayText("UNIT" , g_display_xpos, g_display_ypos_2_3);
    sprintf(error_message, " ERROR %02d", (uint16_t)ndx_image);
    DisplayText(error_message, g_display_xpos, (g_display_ypos_2_2 - 10));
    
    return ndx;
}


/*   Returns 'true' when power up sequence executes normally, and
 *    'false' if an error occurs
 */
static bool PerformPowerUpSequence(uint16_t *post_results)
{
    //This is needed to give time for the ADC system to average 100 values and provide the first samples
    //The delay is extra long to give the fan a chance to spin up to speed
    __delay_ms(3800);
    bool power_on_success = TestPOST(1, post_results, true);  //This holds the test result of the POST
    
    TestLEDCurrentOffset(NULL); // Calibrate current offset

    if (_WDTO == 1)
    {
        SW_WDOG_TIMEOUT_SetHigh(); //set the software watchdog digital output)}
        printf("\n\r\n\r Reset occurred  due to SW WDT.\n\r ------------------------------\n\r");
    }   
    
    // TODO: Determine if we need this
    struct tm Initial_Time;  //This will hold the value of the startup time
    Initial_Time.tm_min = 0; Initial_Time.tm_sec = 0; //Initialize the minutes and seconds to zero

    printf("\n\r POST_Score = %d \n\r", (int) power_on_success);
    return power_on_success;
}


/*
 *  Description:  Prompts the user for a phase and setting number, then
 *                for the corresponding setting value. Stores this value
 *                in flash memory. This is used to update the user interface
 *                settings (e.g. LED colors to blink, amount of therapy time)
 */
static void SetUISetting(void)
{
    uint32_t phase_entered;
    // Adding +1 to the limits because the menu asks for inputs starting at 1
    input_status_t status = WaitForValidUInt32WithLimits(
                                "\n\r\n\r Enter phase (1-13) or 'x' to cancel > ",
                                &phase_entered, POWER_UP_STATE + 1, NUM_UI_STATES);
    if (status == INPUT_CANCELED)
    {
        printf("\r\nOperation canceled\r\n");
    }
    else
    {
        uint32_t setting_entered;
        status = WaitForValidUInt32WithLimits(
                                "\n\r\n\r Enter setting (1-20) or 'x' to cancel > ",
                                &setting_entered, 1, 20);
        if (status == INPUT_CANCELED)
        {
            printf("\r\nOperation canceled\r\n");
        }
        else
        {
            uint32_t value_entered;
            status = WaitForValidUInt32(
                                "\n\r\n\r Enter new value or 'x' to cancel > ",
                                &value_entered);
            if (status == INPUT_CANCELED)
            {
                printf("\r\nOperation canceled\r\n");
            }
            else
            {
                EnterSettingIntoFlash(phase_entered, setting_entered, value_entered);
            }
        }
    }
}


static void DisplayUISettings(void)
{
    const char NAMES_OF_SETTINGS[SETTINGS_PER_UI_STATE][MAXLEN_SETTING_NAME+1] = 
                    {"Image1      ", "Time1       ", "Image2      ", "Time2       ", 
                     "Image3      ", "Time3       ", "Image4      ", "Time4       ", 
                     "Color1R     ", "Color1G     ", "Color1B     ", "Color1 time ", 
                     "Color2R     ", "Color2G     ", "Color2B     ", "Color2 time ", 
                     "Spare0      ", "Spare1      ", "Spare2      ", "Spare3      "};
    printf("\n\r\n\r User Interface Settings stored in FLASH for each Phase");
    printf("\n\r\n\r\t\t1.Power Up\t2.Stand-By\t3.Ready   \t4.Operation \t5.Complete\t6.Paused  \t7.Error  \t8.Insert MCA  \t9.Reading MCA  \t10.Verify SN \t11.MCA Detach \t12.MCA ReadErr \t13.MCA Exp");
            
    uint32_t increment = 0; //general working variable for accessing subsequent data from the FLASH
    int i;
    for (i=0; i<SETTINGS_PER_UI_STATE; i++)
    {
        //Print headers for extra settings beyond the image, time, LED colors.  These are miscelaneous user interface setting
        //                      ----------------1---------------2---------------3---------------4---------------5---------------6---------------7---------------8---------------9---------------10---------------
        if (i==16) {printf("\n\r\n\r---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------");}
        printf("\n\r");
        if (i==16) {printf("\n\r                                LCD Saver (S)                   Therapy Time(S)                                                                                                  ");}
        if (i==17) {printf("\n\r                                LCD Off (S)                                                                                                     Min Period (hrs)                 ");}
        if (i==18) {printf("\n\r                                LCD Refresh (S)                                                                                                                                  ");}
        if (i==19) {printf("\n\r                                                                                                                                                                                 ");}
            
            
            
        printf("\n\r%d.%s\t", i+1, NAMES_OF_SETTINGS[i]);  //had to use large code model for this: Compiler setting xc16-gcc: option = memory model, code = large
        uint32_t phase;
        
        for (phase=0; phase<NUM_UI_STATES; phase++)
        {
            uint32_t setting_value;
            ReadFlash(FLASH_ADDR_OF_SETTINGS + increment, &setting_value, 1, 0);  //read one 32-bit value
            printf("%ld\t\t", setting_value);
            increment++;
        }   
    }   
}


static void DisplayUISettingsLegend(void)
{
    printf("\r\nPower Up,  Image 1:  Mureva logo\r\n");
    printf("Power Up,  Image 2:  Power-up error background\r\n");
    printf("Standby,   Image 1:  'Insert Handle' prompt\r\n");
    printf("Standby,   Image 2:  Screen saver image\r\n");
    printf("Standby,   Time 2:   Idle time before entering screen saver\r\n");
    printf("Standby,   Time 3:   Screen saver duration before turning display off\r\n");
    printf("Ready,     Image 1:  'Ready' prompt\r\n");
    printf("Operation, Image 1:  Full clock image.  Also, this value plus (1 to 60)\r\n");
    printf("                        is used to generate the clock countdown images.\r\n");
    printf("Operation, Image 2:  '0 min' insert image in the middle of the dial.)  This\r\n");
    printf("                          value plus (0 to 9) is used to generate the\r\n");
    printf("                          '0 min' to '9 min' images.\r\n");
    printf("Complete,  Image 1:  'Therapy complete' screen\r\n");
    printf("Paused,    Image 1:  'Paused' screen\r\n");
    printf("Paused,    Image 2:  Small '0 min' insert underneath error message.)  This\r\n");
    printf("                          value plus (0 to 9) is used to generate the\r\n");
    printf("                          small '0 min' to '9 min' images.\r\n");
    printf("Error,     Image 1:  'Unknown error' message. This value plus (1 to 21)\r\n");
    printf("                          denotes additional error messages.\r\n");
}

/*
 *  Stores the hard-coded UI parameter shown below into flash memory. 
 *  This provides a quick way to restore the default values.
 */
static void InitializeUISettings(void)
{
    const uint32_t DEFAULT_SETTINGS[NUM_UI_STATES][SETTINGS_PER_UI_STATE]={
        //                                               R1   G1   B1   Tim1  R2   G2   B2   Tim2
        {1000,    0,    0,    0,    0,    0,    0,    0, 100, 100, 100, 1000,   0,   0,   0,    0, 0,       0,      0,      0},   // Power Up
        {1000,    0, 2100,    0,    0,    0,    0,    0,   0,   0,   0, 1000,   0,   0,   0,    0, 1800,    1800,   10,     0},   // Stand-By
        {2700,    0,    0,    0,    0,    0,    0,    0,   0,   0, 100, 1000,   0,   0,   0,    0, 0,       0,      0,      0},   // Ready
        {4000,    0, 4100,    0,    0,    0,    0,    0,   0, 100,   0, 1000,   0,   0,   0,    0, 300,     0,      0,      0},   // Operate
        {2700,    0,    0,    0,    0,    0,    0,    0,   0, 100,   0,  750,   0,   0,   0,  750, 0,       0,      0,      0},   // Complete
        {2800,    0, 6100,    0,    0,    0,    0,    0,   0,   0, 100,  750,   0,   0,   0,  750, 0,       0,      0,      0},   // Paused
        {2700,    0,    0,    0,    0,    0,    0,    0, 100,   0,   0, 1000, 100,   0,   0,    0, 0,       0,      0,      0},   // Error
        {2700,    0,    0,    0,    0,    0,    0,    0, 100, 100, 100, 1000,   0,   0,   0,    0, 0,       0,      0,      0},   // Insert MCA
        {2700,    0,    0,    0,    0,    0,    0,    0,   0,   0, 100, 1000,   0,   0,   0,    0, 0,       12,     0,      0},   // Reading MCA
        {2700,    0,    0,    0,    0,    0,    0,    0,   0,   0, 100, 1000,   0,   0,   0,    0, 0,       0,      0,      0},   // Verify SN
        {2700,    0,    0,    0,    0,    0,    0,    0, 100,   0,   0, 1000,   0,   0,   0,    0, 0,       0,      0,      0},   // MCA Detached
        {2700,    0,    0,    0,    0,    0,    0,    0, 100,   0,   0, 1000,   0,   0,   0,    0, 0,       0,      0,      0},   // MCA Reading Error
        {2700,    0,    0,    0,    0,    0,    0,    0, 100,   0,   0, 1000,   0,   0,   0,    0, 0,       0,      0,      0},    // MCA Expired
        {2700,    0,    0,    0,    0,    0,    0,    0, 100,   0,   0, 1000,   0,   0,   0,    0, 0,       0,      0,      0},    // MCA Daily Limit
        {2700,    0,    0,    0,    0,    0,    0,    0,   0,   0, 100, 1000,   0,   0,   0,    0, 0,       0,      0,      0}    // MCA_RESUME_CONFIRM_STATE
    };  
    
    printf("\n\r  Are you sure you want to initialize all settings back to default? (Y/N) >");
    if (GetYesOrNo()) 
    {
        printf("\n\r\n\r");
        //Erase all 5 pages of FLASH where these settings are stored
        EraseFlashPages(USER_INTERFACE_SETTINGS_START_PAGE, USER_INTERFACE_SETTINGS_END_PAGE);
        //Write the defaults into FLASH
        uint32_t increment = 0; //general working variable for accessing subsequent data from the FLASH
        int i;
        for (i=0; i<SETTINGS_PER_UI_STATE; i++)
        {
            uint32_t phase;
            for (phase=0; phase<NUM_UI_STATES; phase++)
            {
                uint32_t LongData = DEFAULT_SETTINGS[phase][i];
                WriteFlash(FLASH_ADDR_OF_SETTINGS + increment, &LongData, 1, false);  //write one 32-bit value
                increment++;
            }
        }
        printf("\n\r  Initialization completed.\n\r");   
    }
    else
    {
        printf("\n\r  Initialization canceled.\n\r");   
    }
}

/*
 *   Each of the UI parameters is identified by a phase (i.e. the state within
 *   the UI state machine) and a setting value (e.g. an LED color, a time 
 *   duration).  This function sets the value assigned to a parameter 
 *   identified by 'phase' and 'setting', then stores this value in flash.
 */
static void EnterSettingIntoFlash(uint32_t phase, uint32_t setting, uint32_t value)
{
    uint32_t settings[NUM_UI_STATES*SETTINGS_PER_UI_STATE];  //Temporary storage of all 5 pages of settings
    //Read in the existing settings
    ReadFlash(FLASH_ADDR_OF_SETTINGS, settings, NUM_UI_STATES*SETTINGS_PER_UI_STATE, 0);  //read all the settings contained in the 5 pages
    //Erase all 5 pages of FLASH where these settings are stored
    EraseFlashPages(USER_INTERFACE_SETTINGS_START_PAGE, USER_INTERFACE_SETTINGS_END_PAGE);
    
    // The offset (in longs) for the FLASH address,
    //   where the new setting value will be updated
    uint32_t offset_for_setting = SETTINGS_PER_UI_STATE*(setting-1) + (phase-1);
   
    //Write the defaults into FLASH, except for the value that was just entered
    uint32_t increment = 0; //general working variable for accessing subsequent data from the FLASH
    int i;
    for (i=0; i<SETTINGS_PER_UI_STATE; i++)
    {
        uint32_t j;
        for (j=0; j<NUM_UI_STATES; j++)
        {
            if ((SETTINGS_PER_UI_STATE*i + j) == offset_for_setting)  //write the new value
            {
                WriteFlash(FLASH_ADDR_OF_SETTINGS + increment, &value, 1, false);  //write one 32-bit value
            }
            else       //write the existing setting, these are not to be changed
            {
                WriteFlash(FLASH_ADDR_OF_SETTINGS + increment, &settings[increment], 1, false);  //write one 32-bit value
            }
            increment++;
        }
    }
    printf("\n\r  Setting updated.  \n\r");
    printf("\n\r  Phase %ld, setting %ld with value %ld  \n\r", phase, setting, value);
}

/* Description:  This function collects general system_status, for right now, it only
 *               gets the MCA status as defined below but it can be augmented in the future
 *               for other kinds of status.  The system_status along with the hw_wdog_status
 *               and selftest_status are used to drive the user interface state machine and 
 *               determine error messages to display
 *               Bit   MCA Status
 *                0    MCA reading error
 *                1    MCA expired
 *                2    MCA period
 * 
 * Preconditions:  1-wire EEPROM communications and I2C communications to RTCC
 * Arguments:  pointer to status word
 * Returns:  void
 */
//static void GetSystemStatus(uint16_t *system_status)
//{
//    uint8_t MCAStatus;
//    
//    MCAGetStatus(&MCAStatus);
//    *system_status = (uint16_t)MCAStatus;
//}


